;;; 
 ;; PROFET Copyright 2015 (c) Data Mining and Machine Learning Group,
 ;; National University of Ireland Galway.  
 ;; This file is a part of AIMA Framework  
 ;;
 ;; Licensed under the Apache License, Version 2.0 (the "License");
 ;; you may not use this file except in compliance with the License.
 ;; You may obtain a copy of the License at
 ;;
 ;;      http://www.apache.org/licenses/LICENSE-2.0
 ;;
 ;; Unless required by applicable law or agreed to in writing, software
 ;; distributed under the License is distributed on an "AS IS" BASIS,
 ;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;; See the License for the specific language governing permissions and
 ;; limitations under the License.
;;;

;;; Tetris domain
;;; Tetris is an MDP in which the next state is generated by
;;; inserting the "current" piece as directed by the agent,
;;; moving the "next" piece to be the "current", and
;;; selecting a new piece at random as "next".

(defstruct (tetris (:include mdp 
			     (initial-state (empty-tetris-state)))))

;;; default tetris array sizes

(defvar *tetris-x* 6)
(defvar *tetris-y* 10)

;;; tetris pieces

(defvar *red*) (defvar *yellow*) (defvar *purple*) (defvar *turquoise*) 
(defvar *blue*) (defvar *green*) (defvar *orange*) 

(defvar *tetris-pieces*)

;;; State definition: array contains nil or the colour of the piece
;;; in each square. tops is used to keep track of the next empty
;;; square in each column.

(defstruct (tetris-state (:print-function print-tetris))
  (array (make-array (list *tetris-x* *tetris-y*) :initial-element nil))
  (tops (make-array (list *tetris-x*) :initial-element 0)) ;;; next empty space
  current				; the current piece
  next					; the next piece
  (terminalp nil)                       ; flag to indicate game over
  )

(defstruct tetris-piece
  color					; color
  shapes				; list of arrays by orientation
  bottoms				; list of bottom contours
  tops                                  ; list of top contours
  (default 0)				; default orientation
  )

(defstruct (tetris-move (:type list))
  column				; left-most column of piece
  orientation				; piece orientation
  )


;;; Definitions of tetris as an MDP

(defmethod mdp-next-state ((tetris tetris) state action)
  (let ((succ (copy-tetris-state state)))
    (setf (tetris-state-array succ) (copy-array (tetris-state-array succ)))
    (setf (tetris-state-tops succ) (copy-array (tetris-state-tops succ)))
    (tetris-make-move succ action)  ;;; destructively changes array, tops
    (setf (tetris-state-current succ) (tetris-state-next succ))
    (setf (tetris-state-next succ) (tetris-choose state))
    succ))

(defmethod terminal? ((tetris tetris) state) 
  (tetris-state-terminalp state))

(defmethod mdp-reward ((tetris tetris) state) (declare (ignore state))
  6)

;;; main defuns

;;; The state is initially empty; random choices for current and next pieces

(defun empty-tetris-state ()
  (let ((state (make-tetris-state)))
    (setf (tetris-state-current state) (tetris-choose state))
    (setf (tetris-state-next state) (tetris-choose state))
    state))

;;; random choice currently uniform; I suspect real tetris has correlations

(defun tetris-choose (state) (declare (ignore state))
  (random-element *tetris-pieces*))

;;; tetris-make-move makes the necessary changes to the array and tops.
;;; Purely side-effects.

(defun tetris-make-move (state move)
  (let ((current (tetris-state-current state)))
    (cond ((tetris-legal-move? state current move)
	   (tetris-drop-piece state current move)
	   (tetris-eliminate-rows state))
	  (t (error "The move ~A is illegal with piece ~A."
		    move (tetris-piece-color current))))))

;;; A move is legal as long as the piece doesn't protrude off the edge
;;; of the board at the right.

(defun tetris-legal-move? (state piece move)
  (let* ((ncols (array-dimension (tetris-state-array state) 0))
	 (column (tetris-move-column move))
	 (orientation (tetris-move-orientation move))
	 (shape (nth orientation (tetris-piece-shapes piece))))
    (<= (+ column (array-dimension shape 0)) ncols)))

;;; To drop in a piece, first establish the right row at which it
;;; will be in contact with the existing pieces. Then copy the
;;; piece into the right squares. Then readjust tops.

(defun tetris-drop-piece (state piece move)
  (let* ((array (tetris-state-array state))
	 (nrows (array-dimension array 1))
	 (tops (tetris-state-tops state))
	 (column (tetris-move-column move))
	 (orientation (tetris-move-orientation move))
	 (piece-bottoms (nth orientation (tetris-piece-bottoms piece)))
	 (piece-tops (nth orientation (tetris-piece-tops piece)))
	 (shape (nth orientation (tetris-piece-shapes piece)))
	 (width (array-dimension shape 0))
	 (height (array-dimension shape 1))
	 (contact-row 0)) 
    (dotimes (x width)
      (setq contact-row (max contact-row (- (aref tops (+ column x))
					    (aref piece-bottoms x)))))
    (cond ((> (+ contact-row height) nrows) ;;; state overflow!!
	   (setf (tetris-state-terminalp state) t))
	  (t (dotimes (x width)
	       (dotimes (y height)
		 (let ((color (aref shape x y)))
		   (when color 
		     (setf (aref array (+ column x) (+ contact-row y)) 
		           color)))))
		       
	     (dotimes (x width)
	       (setf (aref tops (+ column x)) 
		     (+ contact-row (aref piece-tops x))))))))

;;; Each full row is eliminated and the pieces above it
;;; are moved down. If a square in that row is the
;;; top square, then we need to recompute the top by search.
;;; If we eliminate rows bottom-up, we need only redo tops once.
;;; However, this is too tricky for now.

(defun tetris-eliminate-rows (state)
  (let* ((array (tetris-state-array state))
	 (ncols (array-dimension array 0))
	 (nrows (array-dimension array 1))
	 (tops (tetris-state-tops state))
	 (shift 0))
    (dotimes (y nrows)
      (cond ((full-row? array ncols y)  ;;; delete the row
	     (incf shift)
	     (dotimes (x ncols) (setf (aref array x y) nil)))
	    (t (when (plusp shift)                  ;;; copy the row down
		 (dotimes (x ncols)
		   (setf (aref array x (- y shift)) (aref array x y))
		   (setf (aref array x y) nil))))))
    (dotimes (x ncols)
      (setf (aref tops x) (find-top array x (1- nrows))))))


(defun full-row? (array ncols y)
  "Return true iff row y in array (of width ncols) is all non-nil."
  (dotimes (x ncols t) (unless (aref array x y) (return nil))))

(defun find-top (array x row)
  "Find 1+ the topmost non-nil square in column x, starting from given row."
  (dotimes (y1 (1+ row) 0) 
    (let ((y (- row y1))) (when (aref array x y) (return (1+ y))))))

;;; print-tetris prints out the state in ascii.

(defun print-tetris (state &rest rest) (declare (ignore rest))
  (let* ((array (tetris-state-array state))
	 (ncols (array-dimension array 0))
	 (nrows (array-dimension array 1)))
    (format t "~%+") (dotimes (x ncols) (format t "-")) (format t "+")
    (dotimes (y1 nrows)
      (let ((y (- nrows y1 1)))
	(format t "~%|")
	(dotimes (x ncols)
	  (if (aref array x y)
	      (format t "~S" (aref array x y))
	    (format t " ")))
	(format t "|")
	))
    (format t "~%+") (dotimes (x ncols) (format t "-")) (format t "+")
    (format t "~%Current: ~S Next: ~S Tops: ~A"
	    (tetris-piece-color (tetris-state-current state))
	    (tetris-piece-color (tetris-state-next state))
	    (tetris-state-tops state))
    ))


;;; Now for the piece shapes.

; RED
; 0:    1:
;       X
; XXXX  X
;       X
;       X

(setq *red* (make-tetris-piece
	       :color 'R
	       :shapes (list (make-array '(4 1) 
					 :initial-contents '((R) (R) (R) (R)))
			     (make-array '(1 4) 
					 :initial-contents '((R R R R))))
			     
	       :bottoms (list (make-array '(4) :initial-contents '(0 0 0 0))
			      (make-array '(1) :initial-contents '(0)))
	       :tops    (list (make-array '(4) :initial-contents '(1 1 1 1))
			      (make-array '(1) :initial-contents '(4)))
	       ))
			      

; YELLOW
; 0:    1:    2:    3:
; XXX    X     X    X
;  X    XX    XXX   XX
;        X          X


(setq *yellow* (make-tetris-piece
	       :color 'Y
	       :shapes (list (make-array '(3 2) 
			      :initial-contents '((NIL Y) (Y Y) (NIL Y)))
			     (make-array '(2 3) 
			      :initial-contents '((NIL Y NIL) (Y Y Y)))
			     (make-array '(3 2) 
			      :initial-contents '((Y NIL) (Y Y) (Y NIL)))
			     (make-array '(2 3) 
			      :initial-contents '((Y Y Y) (NIL Y NIL))))
	       :bottoms (list (make-array '(3) :initial-contents '(1 0 1))
			      (make-array '(2) :initial-contents '(1 0))
			      (make-array '(3) :initial-contents '(0 0 0))
			      (make-array '(2) :initial-contents '(0 1)))
	       :tops    (list (make-array '(3) :initial-contents '(2 2 2))
			      (make-array '(2) :initial-contents '(2 3))
			      (make-array '(3) :initial-contents '(1 2 1))
			      (make-array '(2) :initial-contents '(3 2)))
	       ))
			      

; PURPLE
; 0:    1:    2:    3:
; X     XX    XXX    X
; XXX   X       X    X
;       X           XX

(setq *purple* (make-tetris-piece
	       :color 'P
	       :shapes (list (make-array '(3 2) 
			      :initial-contents '((P P) (P NIL) (P NIL)))
			     (make-array '(2 3) 
			      :initial-contents '((P P P) (NIL NIL P)))
			     (make-array '(3 2) 
			      :initial-contents '((NIL P) (NIL P) (P P)))
			     (make-array '(2 3) 
			      :initial-contents '((P NIL NIL) (P P P))))
	       :bottoms (list (make-array '(3) :initial-contents '(0 0 0))
			      (make-array '(2) :initial-contents '(0 2))
			      (make-array '(3) :initial-contents '(1 1 0))
			      (make-array '(2) :initial-contents '(0 0)))
	       :tops    (list (make-array '(3) :initial-contents '(2 1 1))
			      (make-array '(2) :initial-contents '(3 3))
			      (make-array '(3) :initial-contents '(2 2 2))
			      (make-array '(2) :initial-contents '(1 3)))
	       ))

; TURQUOISE
; 0:    1:    2:    3:
;   X   X     XXX   XX
; XXX   X     X      X
;       XX           X

(setq *turquoise* (make-tetris-piece
	       :color 'T
	       :shapes (list (make-array '(3 2) 
			      :initial-contents '((T NIL) (T NIL) (T T)))
			     (make-array '(2 3) 
			      :initial-contents '((T T T) (T NIL NIL)))
			     (make-array '(3 2) 
			      :initial-contents '((T T) (NIL T) (NIL T)))
			     (make-array '(2 3) 
			      :initial-contents '((NIL NIL T) (T T T))))
	       :bottoms (list (make-array '(3) :initial-contents '(0 0 0))
			      (make-array '(2) :initial-contents '(0 0))
			      (make-array '(3) :initial-contents '(0 1 1))
			      (make-array '(2) :initial-contents '(2 0)))
	       :tops    (list (make-array '(3) :initial-contents '(1 1 2))
			      (make-array '(2) :initial-contents '(3 1))
			      (make-array '(3) :initial-contents '(2 2 2))
			      (make-array '(2) :initial-contents '(3 3)))
	       ))

; BLUE
; 0:    1:
; X      XX
; XX    XX
;  X

(setq *blue* (make-tetris-piece
	       :color 'B
	       :shapes (list (make-array '(2 3) 
			      :initial-contents '((NIL B B) (B B NIL)))
			     (make-array '(3 2) 
			      :initial-contents '((B NIL) (B B) (NIL B))))
	       :bottoms (list (make-array '(2) :initial-contents '(1 0))
			      (make-array '(3) :initial-contents '(0 0 1)))
	       :tops    (list (make-array '(2) :initial-contents '(3 2))
			      (make-array '(3) :initial-contents '(1 2 2)))
	       ))

; GREEN
; 0:    1:
;  X    XX
; XX     XX
; X

(setq *green* (make-tetris-piece
	       :color 'G
	       :shapes (list (make-array '(2 3) 
			      :initial-contents '((G G NIL) (NIL G G)))
			     (make-array '(3 2) 
			      :initial-contents '((NIL G) (G G) (G NIL))))
	       :bottoms (list (make-array '(2) :initial-contents '(0 1))
			      (make-array '(3) :initial-contents '(1 0 0)))
	       :tops    (list (make-array '(2) :initial-contents '(2 3))
			      (make-array '(3) :initial-contents '(2 2 1)))
	       ))

; ORANGE
; 0:
; XX
; XX

(setq *orange* (make-tetris-piece
	       :color 'O
	       :shapes (list (make-array '(2 2) 
			      :initial-contents '((O O) (O O))))
	       :bottoms (list (make-array '(2) :initial-contents '(0 0)))
	       :tops    (list (make-array '(2) :initial-contents '(2 2)))
	       ))


(setq *tetris-pieces* (list *red* *yellow* *purple* *turquoise* 
			    *blue* *green* *orange*))
