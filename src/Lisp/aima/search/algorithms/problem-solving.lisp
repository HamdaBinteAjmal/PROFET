;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*- File: problems-solving.lisp
;;; 
 ;; PROFET Copyright 2015 (c) Data Mining and Machine Learning Group,
 ;; National University of Ireland Galway.  
 ;; This file is a part of AIMA Framework 
 ;;
 ;; Licensed under the Apache License, Version 2.0 (the "License");
 ;; you may not use this file except in compliance with the License.
 ;; You may obtain a copy of the License at
 ;;
 ;;      http://www.apache.org/licenses/LICENSE-2.0
 ;;
 ;; Unless required by applicable law or agreed to in writing, software
 ;; distributed under the License is distributed on an "AS IS" BASIS,
 ;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;; See the License for the specific language governing permissions and
 ;; limitations under the License.
;;;
;;;; Manipulating Nodes

(defstruct node
  "Node for generic search.  A node contains a state, a domain-specific
  representation of a point in the search space.  A node also contains 
  bookkeeping information such as the cost so far (g-cost) and estimated cost 
  to go (h-cost). [2e p 69]"
  (state (required))        ; a state in the domain
  (parent nil)              ; the parent node of this node
  (action nil)              ; the domain action leading to state
  (depth 0)                 ; depth of node in tree (root = 0)
  (g-cost 0)                ; path cost from root to node
  (h-cost 0)                ; estimated distance from state to goal
  (f-cost 0)                ; g-cost + h-cost
  )

(defmethod print-object ((node node) stream) 
  (format stream "#<NODE f(~D) = g(~D) + h(~D) state:~A>" (node-f-cost node)
	  (node-g-cost node) (node-h-cost node) (node-state node)))

(defun expand (node problem)
  "Generate a list of all the nodes that can be reached from a node. [2e p 72]"
  ;; Note the problem's successor-fn returns a list of (action . state) pairs.
  ;; This function turns each of these into a node.
  (when *recording* (incf (run-count *current-run*)))
  (let ((nodes nil))
    (loop for (action . result) in (successor-fn problem (node-state node)) do
      (let* ((g (+ (node-g-cost node) 
		   (step-cost problem (node-state node) action result)))
	     (h (h-cost problem result)))
	(push
	 (make-node 
	  :state result
	  :parent node 
	  :action action 
	  :g-cost g 
	  :depth (1+ (node-depth node)) 
	  :h-cost h
	  :f-cost (+ g h))
	 nodes)))
    nodes))

(defun create-start-node (problem)
  "Make the starting node, corresponding to the problem's initial state."
  (let ((h (h-cost problem (problem-initial-state problem))))
    (make-node :state (problem-initial-state problem)
	       :h-cost h :f-cost h)))

;;;; Extracting solutions

(defun solution (node &optional (actions-so-far nil))
  "Return a list of actions that will lead to the node's state."
  (cond ((null node) actions-so-far)
	((null (node-parent node)) actions-so-far)
	(t (solution (node-parent node)
		     (cons (node-action node) actions-so-far)))))


;;;; Comparing Algorithms

(defun compare-search-algorithms (problem-generator algorithms &key (n 10))
  "Run each algorithm on N problems (as generated by problem-generator)
  and compare the results for nodes expanded and for path cost."
  (let ((random-state (make-random-state t)))
    (format t "~&Solved  Cost  Length  Nodes  Algorithm")
    (format t "~&====== ====== ====== ======= =========")
    (loop for algorithm in algorithms do
	 (let ((g-cost 0)
	       (num-expanded 0)
	       (num-solved 0)
	       (path-length 0)
	       (copy-of-random-state (make-random-state random-state)))
	   (loop for i from 1 to n do
		(setf *recording* t *current-run* (make-run))
		(let* ((problem (let ((*random-state* copy-of-random-state))
				  (funcall problem-generator)))
		       (solution (funcall algorithm problem)))
		  (incf num-expanded (run-count *current-run*))
		  (when (not (eq solution :failure))
		    (incf num-solved)
		    (incf path-length (length solution))
		    (incf g-cost (path-cost problem solution)))))
	   (let ((M (if (= num-solved 0) 1 num-solved)))
	     (format t "~&~5D  ~6,1F ~6,1F ~7,1F ~A~%"
		     num-solved (/ g-cost M) (/ path-length M)
		     (/ num-expanded N) algorithm)))))
  (values))



